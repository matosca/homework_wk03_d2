# Homework: Pizza Shop

## Today

Today we created a program that tracks pizza orders. We created a Ruby class (`PizzaOrder`) and a database table (pizza\_orders) which is able to persist objects of this type. Currently, our database table is structured as follows...

| first_name | last_name | topping         | quantity |
|------------|-----------|-----------------|----------|
| Luke       | Skywalker | Pepperoni       | 2        |
| Leia       | Organa    | Ham & Pineapple | 1        |

Our table stores a combination of pizza and customer details. This isn't ideal for a number of reasons. If a single customer makes many orders then their details appear in our database many times. Firstly, this is not efficient. It would be much nicer if we could create a customer once and then attribute many orders too them. This would also help to protect us against typos as we would only have to submit a new customer once.

## Tomorrow

Tomorrow we are going to refactor our program. We will add another class, `Customer`, which will also have the full set of CRUD actions. This class will be responsible for the customer details, while `PizzaOrders` will be responsible for the pizza order that is being processed.

We will also extract some of the database connection code into a new class, `SqlRunner`.

Once completed, our tables should be structured as follows...

### customers

| id | first_name | last_name |
|----|------------|-----------|
| 1  | Luke       | Skywalker |
| 2  | Leia       | Organa    |

### pizza_orders

| id | topping         | quantity | customer_id |
|----|-----------------|----------|-------------|
| 1  | Pepperoni       | 2        | 1           |
| 2  | Ham & Pineapple | 1        | 2           |
| 3  | Meat Feast      | 1        | 1           |

## Task

Your task this evening is to read over the completed end\_code for tomorrow's lesson, understand it as much as possible, and answer the following questions.

1) What is the relationship between customers and pizza\_orders?
It is a one to many relationship because one pizza_order can only belong to one only customer; however, a customer can have one or more pizza_orders. For instance, in customers table id 1 first_name Luke have two different orders in pizza_orders table which are id 1 topping Pepperoni and id 3 topping Meat Feast.

2) At what point is the id of a `PizzaOrder` created?
The id of a 'PizzaOrder' is created when defined method save( ).  This method will save any instance of PizzaOrder we new up. Since this method is conected to our database table (pizza\_orders), each instance saved will be automatically assigned with an unique id  (type SERIAL) by our sql database.

3) At what point do we assign a value to the `@id` instance variables of our objects?
The id of a 'PizzaOrder' is created when defined method save( ). As seen in the code below,  our database will execure pizza_orders table and the id generated by the database is stored in variable @id for our instance of PizzaOred class. 

def save
sql = "INSERT INTO pizza_orders (customer_id, topping, quantity)
VALUES ($1, $2, $3)
RETURNING id"
values = [@customer_id, @topping, @quantity]
@id = SqlRunner.run(sql, values).first['id'].to_i
end

4) Name 2 things that the `Customer`'s `@id` property is used for.
    For instance, it has been used for reference customer_id in pizza_orders as well as in the method save( ) to keep track of instances of Customer class.

5) Why might it be important to check if `options['id']` is `nil` in our `initialize` method before assigning `@id` the value of `options[‘id’].to_i?`
    The reason for that is to prevent having same id on more than one 'Customer'. For example, we would not like to have the pizza_orders of one particular customer onto a new customer.

6) What are the responsibilities of `SqlRunner`?
    SqlRunner is a new Ruby class that allows us to run the PG library which handles the connection to a database and executes the SQL script. This enables a faster way of executing this code whenever we pass it in any of our classes PizzaOrder and Customer.
7) How does `SqlRunner` improve the quality of our code?
By runing a new file with class SqlRunner, it allows us to prevent repetition and keep it DRY since all the db.connect(), db.prepare(), db.exec_prepared() and db.close it is presented in one single class that can be used anytime.
